import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
import imageio
from pathlib import Path

STEP = 10          # points added per frame
TOTAL = 1000       # total points; if None, use all available rows in CSVs
OUTPUT = 'circular_samples.gif'

# Load CSVs generated by sample_toy_guided.py
base_dir = Path('./toy_guided_samples')
recon_csv = base_dir / 'samples_recon.csv'
phys_csv  = base_dir / 'samples_physics.csv'
guid_csv  = base_dir / 'samples_guided.csv'

if not (recon_csv.exists() and phys_csv.exists() and guid_csv.exists()):
    raise FileNotFoundError('CSV files not found in toy_guided_samples/. Run sample_toy_guided.py first.')

# Load full arrays first
recon_full = np.loadtxt(recon_csv, delimiter=',')
phys_full  = np.loadtxt(phys_csv,  delimiter=',')
guid_full  = np.loadtxt(guid_csv, delimiter=',')

# Determine TOTAL dynamically if not specified
if TOTAL is None:
    TOTAL = min(len(recon_full), len(phys_full), len(guid_full))

# Truncate arrays to TOTAL
recon = recon_full[:TOTAL]
phys  = phys_full [:TOTAL]
guid  = guid_full [:TOTAL]

# Calculate MSE against unit circle for each method
def calculate_mse(points):
    """Compute MSE exactly as in sample_toy_guided.py.
    For each sample, compute r^2 âˆ’ 1, then square this residual and take the mean.
    """
    res = np.sum(points**2, axis=1) - 1.0  # r^2 - 1
    mse = np.mean(res**2)
    return mse

mse_recon = calculate_mse(recon)
mse_phys = calculate_mse(phys)
mse_guid = calculate_mse(guid)

# Axis limits (pad 10%)
all_pts = np.vstack([recon, phys, guid])
min_xy = all_pts.min(0)
max_xy = all_pts.max(0)
pad = 0.1 * (max_xy - min_xy)
lims = [(min_xy[i] - pad[i], max_xy[i] + pad[i]) for i in range(2)]

# Inset region coordinates (smaller, centred near the unit circle in bottom-left quadrant)
inset_center = (-0.89, -0.456)
inset_width = 0.2  # smaller zoom window
inset_bounds = [
    (inset_center[0] - inset_width/2, inset_center[0] + inset_width/2),
    (inset_center[1] - inset_width/2, inset_center[1] + inset_width/2)
]

frames = []
for k in range(STEP, TOTAL + STEP, STEP):
    fig, ax = plt.subplots(figsize=(6,6))
    
    # Plot unit circle
    theta = np.linspace(0, 2*np.pi, 400)
    ax.plot(np.cos(theta), np.sin(theta), '--', color='grey', lw=1, label='Unit circle')
    
    # Plot sample points with MSE in legend
    ax.scatter(recon[:k,0], recon[:k,1], s=10, c='blue',
              label=f'Vanilla Diffusion Model (Physics residual: {mse_recon:.2e})')
    ax.scatter(phys [:k,0], phys [:k,1], s=10, c='purple',
              label=f'Physics-Informed Diffusion Model (Physics residual: {mse_phys:.2e})')
    ax.scatter(guid [:k,0], guid [:k,1], s=10, c='green',
              label=f'Ours: Tuned-Physics Guidance Diffusion Model (Physics residual: {mse_guid:.2e})')
    
    ax.set_xlim(lims[0]); ax.set_ylim(lims[1])
    ax.set_aspect('equal','box')
    ax.set_title(f'Combined samples (n={k})')
    
    
    # Add inset axes for magnified view
    axins = inset_axes(ax, width="30%", height="30%", loc="center")
    
    # Plot the same data in the inset
    axins.plot(np.cos(theta), np.sin(theta), '--', color='grey', lw=1)
    axins.scatter(recon[:k,0], recon[:k,1], s=5, c='blue')
    axins.scatter(phys [:k,0], phys [:k,1], s=5, c='purple')
    axins.scatter(guid [:k,0], guid [:k,1], s=5, c='green')
    
    # Set inset limits
    axins.set_xlim(inset_bounds[0])
    axins.set_ylim(inset_bounds[1])
    axins.set_aspect('equal', 'box')
    # Remove tick marks / labels but retain box
    axins.set_xticks([])
    axins.set_yticks([])
    
    # Draw a box around the region in the main plot
    from matplotlib.patches import Rectangle
    rect = Rectangle(
        (inset_bounds[0][0], inset_bounds[1][0]),
        inset_width, inset_width,
        linewidth=1, edgecolor='black', facecolor='none', linestyle=':'
    )
    ax.add_patch(rect)
    
    # Add connecting lines
    from matplotlib.patches import ConnectionPatch
    # Connect top-left corner
    con1 = ConnectionPatch(
        xyA=(inset_bounds[0][0], inset_bounds[1][1]), coordsA=ax.transData,  # top-left in data coords
        xyB=(0, 1), coordsB=axins.transAxes,  # top-left in inset axes coords
        linestyle=":", color="black"
    )
    fig.add_artist(con1)
    # Connect bottom-right corner
    con2 = ConnectionPatch(
        xyA=(inset_bounds[0][1], inset_bounds[1][0]), coordsA=ax.transData,  # bottom-right in data coords
        xyB=(1, 0), coordsB=axins.transAxes,  # bottom-right in inset axes coords
        linestyle=":", color="black"
    )
    fig.add_artist(con2)
    
    
    # Legend
    ax.legend(framealpha=0.8, fontsize=7, loc='lower left')
    
    # Save frame
    tmp = f'__frame_{k}.png'
    plt.savefig(tmp, dpi=120)
    plt.close(fig)
    frames.append(imageio.imread(tmp))
    Path(tmp).unlink()  # remove temp file

imageio.mimsave(OUTPUT, frames, duration=0.2)
print(f'Saved {OUTPUT} with {len(frames)} frames (step {STEP})') 